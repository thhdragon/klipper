## Key Focus Areas

### 1. Mathematical Logic Extraction Over Implementation
- **DO**: Extract kinematic equations and derive optimal control algorithms
- **DON'T**: Document Klipper's specific file structure or API calls
- **Example**: "Given a CoreXY kinematics system, derive the transformation matrix and prove that the system maintains orthogonal motion. How would Rust's type system prevent invalid coordinate transformations at compile time?"# 3D Printer LLM Agent Dataset Generation Prompt

## Mission Statement
You are tasked with creating a comprehensive dataset optimized for training **Phi-4-mini-flash-reasoning** on advanced 3D printer control systems. Drawing inspiration from the **Nemotron-Math-HumanReasoning** dataset methodology, you will extract universal logic, reasoning patterns, and problem-solving approaches from Klipper's source code. Focus on creating **extended reasoning-style solutions** that demonstrate the "how" and "why" of 3D printer control decisions, with emphasis on **Rust programming paradigms** and **mathematical reasoning chains**.

## Core Objective for Phi-4-mini-flash-reasoning
Extract the **logic and reasoning** behind Klipper's operations through **step-by-step mathematical and logical reasoning chains**. The model is trained on synthetic mathematical content from advanced reasoning models, so structure your dataset to match this reasoning-focused approach. Emphasize **Rust's ownership model, memory safety, and concurrent programming patterns** as they apply to real-time 3D printer control.

## Nemotron-Math-HumanReasoning Integration Strategy

### Learning from Human Reasoning Patterns
The Nemotron dataset demonstrates that human-authored reasoning solutions significantly outperform automated generations in teaching models to think systematically. Apply these principles:

**Extended Reasoning Style**: Structure each problem as a comprehensive thought process, showing:
- Initial problem assessment and constraint identification
- Step-by-step logical progression with mathematical justification  
- Error checking and boundary condition analysis
- Alternative approaches and trade-off considerations

**Multi-Stage Solution Development**: Create solutions at different depth levels:
- **Stage 1**: Core problem identification and basic mathematical formulation
- **Stage 2**: Detailed derivation with Rust safety considerations
- **Stage 3**: Implementation challenges and edge case handling
- **Stage 4**: Optimization insights and real-world constraints

**Human-Like Problem Solving**: Demonstrate the natural progression of engineering thought:
- "First, let me understand what's happening physically..."
- "The mathematical constraint here suggests..."
- "From a safety perspective, we must ensure..."
- "Rust's type system helps us guarantee..."

## Phi-4-Mini-Flash-Reasoning Optimization Strategy

### Mathematical Reasoning Focus
The model is trained exclusively on synthetic mathematical content generated by advanced reasoning models, so structure each dataset entry as:
- **Mathematical formulation** of the control system problem
- **Step-by-step logical reasoning** chains with explicit justification
- **Proof-like demonstrations** showing correctness and safety bounds
- **Quantitative analysis** of edge cases and failure modes

### Rust Programming Integration
Frame reasoning problems to teach both domain knowledge AND safe implementation:
- **Ownership and borrowing** patterns for hardware resource management
- **Concurrent programming** models for real-time control loops
- **Zero-cost abstractions** enabling efficient motor control algorithms
- **Type system guarantees** preventing runtime errors in critical systems
- **Compile-time verification** of mathematical constraints and physical limits

### Extended Reasoning Structure
Mirror the Nemotron dataset's human-like reasoning progression:
1. **Problem Recognition**: "When analyzing this control system challenge..."
2. **Mathematical Foundation**: "The underlying physics requires..."
3. **Safety Constraints**: "Critical bounds must be maintained because..."
4. **Rust Implementation**: "The type system enforces these guarantees by..."
5. **Verification**: "We can prove correctness through..."

### 1. Logic Extraction Over Implementation
- **DO**: Extract the reasoning behind motion planning algorithms
- **DON'T**: Document Klipper's specific file structure or API calls
- **Example**: Instead of "Klipper uses trapezoid.py for motion", extract "How should a printer OS calculate acceleration curves to minimize vibration while maximizing speed?"

### 2. Rust-Centric Universal Principles
- Extract concepts applicable to any real-time control system
- Focus on memory-safe concurrent programming patterns
- Emphasize zero-cost abstractions and compile-time guarantees
- Demonstrate how Rust's ownership model prevents common embedded systems bugs

### 3. Mathematical Reasoning-Style Query Generation
Structure findings as mathematical proofs and logical derivations that:
- Present formal problem statements with clear mathematical notation
- Build reasoning chains step-by-step with logical justification
- Include Rust code patterns that enforce mathematical constraints
- Demonstrate verification through type system guarantees

## Dataset Categories to Generate

## Dataset Categories with Rust Integration

### Motion Control & Kinematics with Mathematical Proofs
- **Mathematical Formulation**: Derive motion equations and prove stability bounds
- **Rust Safety Logic**: How ownership prevents simultaneous motor access conflicts
- **Concurrency Patterns**: Lock-free algorithms for real-time motion planning
- **Type Safety**: Using Rust's type system to enforce physical constraints (positive velocities, bounded accelerations)

### Thermal Management with Control Theory
- **PID Mathematical Analysis**: Derive optimal PID parameters through mathematical optimization
- **Rust Memory Safety**: Safe handling of temperature sensor data without buffer overflows
- **Concurrent Temperature Monitoring**: Async/await patterns for non-blocking thermal management
- **Compile-time Verification**: Using const generics to enforce temperature bounds

### Error Handling & Recovery with Formal Verification
- **State Machine Proofs**: Mathematical verification of state transition safety
- **Rust Error Propagation**: Using Result<T,E> for safe error handling without panics
- **Resource Management**: RAII patterns for hardware resource cleanup
- **Deadlock Prevention**: Mathematical proof of deadlock-freedom in concurrent systems

### Real-Time Control Systems with Performance Guarantees
- **Timing Analysis**: Mathematical bounds on worst-case execution time
- **Zero-Cost Rust Abstractions**: Compile-time optimizations that maintain real-time guarantees
- **Memory Pool Management**: Lock-free allocators for deterministic memory access
- **Interrupt Safety**: Proving interrupt handler correctness through Rust's type system

## Output Format for Extended Reasoning (Nemotron-Style)

Structure each dataset entry as a comprehensive reasoning demonstration:

```
**Control System Problem**: [Formal engineering challenge with clear parameters]

**Physical Context & Constraints**:
- Hardware limitations: [e.g., stepper motor torque limits, sensor precision]
- Real-time requirements: [e.g., 1kHz control loop, 50Î¼s interrupt latency]  
- Safety requirements: [e.g., thermal runaway prevention, collision avoidance]

**Mathematical Analysis**:
Let me work through this systematically...

Step 1: [Physical law application with mathematical derivation]
The fundamental constraint here is [equation], which leads us to...

Step 2: [Control theory application with stability analysis]  
To ensure system stability, we need to verify that [mathematical condition]...

Step 3: [Optimization with trade-off analysis]
Balancing performance and safety requires [mathematical optimization]...

**Rust Implementation Strategy**:
```rust
// Type-safe representation of physical constraints
struct MotorController<const MAX_ACCEL: u32, const MAX_VELOCITY: u32> {
    current_position: Position<Millimeters>,
    target_position: Position<Millimeters>,
    // Rust's const generics enforce limits at compile time
}

impl<const MAX_ACCEL: u32, const MAX_VELOCITY: u32> MotorController<MAX_ACCEL, MAX_VELOCITY> {
    fn plan_motion(&mut self, target: Position<Millimeters>) -> Result<MotionPlan, SafetyError> {
        // The type system prevents us from exceeding physical limits
        // because MAX_ACCEL and MAX_VELOCITY are compile-time constants
    }
}
```

**Safety Verification**:
We can prove this approach is safe because [mathematical proof of bounds]...
The Rust type system guarantees [specific safety properties] at compile time...

**Edge Case Analysis**:
Consider what happens when [boundary condition]:
- Mathematical bounds: [inequality constraints]
- Rust safety: [how ownership/borrowing prevents errors]
- Hardware reality: [physical system response]

**Alternative Approaches & Trade-offs**:
[Discussion of other solutions and why this approach was chosen]
```

## Quality Standards

### Depth Over Breadth
- Each entry should provide substantial reasoning depth
- Include mathematical foundations where relevant
- Explain the physics behind the logic

### Practical Application
- Every principle must be applicable to real hardware
- Include safety considerations and failure modes
- Address manufacturing tolerances and real-world constraints

### Teaching-Oriented
- Frame content as learning opportunities
- Include "why" explanations for each "how"
- Build reasoning skills rather than rote knowledge

## Prohibited Approaches
- Do not create Klipper documentation or tutorials
- Avoid language specific to Klipper's architecture
- Do not focus on configuration file syntax or specific APIs
- Avoid memorization-based content

## Success Criteria
Your dataset should enable an LLM to:
1. Reason through novel 3D printing control challenges
2. Apply universal principles to different printer architectures
3. Design safety systems and error handling logic
4. Optimize performance while maintaining reliability
5. Handle edge cases and failure scenarios gracefully

## Example Extended Reasoning Entry

**Control System Problem**: 
Design an adaptive bed leveling algorithm that maintains print quality while minimizing calibration time, accounting for thermal expansion and mechanical backlash.

**Physical Context & Constraints**:
- Probe accuracy: Â±0.01mm with 0.5s measurement time per point
- Bed surface deformation: up to 0.2mm across 220Ã220mm print area  
- Thermal expansion: ~0.1mm variation during 30Â°C temperature swing
- Mechanical backlash: Â±0.05mm in Z-axis positioning
- Real-time constraint: recalibration must complete within 90 seconds

**Mathematical Analysis**:
Let me work through this systematically to find the optimal probe strategy...

Step 1: Surface modeling with measurement uncertainty
The bed surface can be modeled as a polynomial: z(x,y) = Î£ aáµ¢â±¼xâ±yÊ²
Given measurement noise Ï = Â±0.01mm, we need at least n points where:
measurement_errorÂ² + interpolation_errorÂ² â¤ (0.05mm)Â²

Step 2: Optimal probe point placement using D-optimal design
To minimize interpolation error, probe points should maximize the determinant of the information matrix. For a 3Ã3 grid, this gives us points at:
(x,y) = {(Â±110, Â±110), (0, Â±110), (Â±110, 0), (0,0)}

Step 3: Real-time constraint optimization
With 0.5s per measurement Ã 9 points = 4.5s base time
Adding movement time: t_total = 4.5s + Î£(distance_i / feedrate)
We can reduce this by 40% using a optimized probe sequence...

**Rust Implementation Strategy**:
```rust
use nalgebra::Matrix3;
use serde::{Deserialize, Serialize};

#[derive(Debug, Copy, Clone)]
struct ProbePoint {
    position: Vector2<f32>,
    measured_height: f32,
    measurement_error: f32,
    timestamp: std::time::Instant,
}

// Const generics enforce grid size at compile time
struct BedLevelingController<const GRID_SIZE: usize> {
    probe_points: [Option<ProbePoint>; GRID_SIZE],
    surface_model: SurfaceModel,
}

impl<const GRID_SIZE: usize> BedLevelingController<GRID_SIZE> {
    fn adaptive_probe(&mut self) -> Result<CompensationMesh, CalibrationError> {
        // Ownership ensures probe data integrity - no concurrent modification
        let mut probe_sequence = self.calculate_optimal_sequence()?;
        
        for point in probe_sequence.drain(..) {
            // Rust prevents us from using stale probe data through borrowing rules
            let measurement = self.probe_at_position(point.position)?;
            self.update_surface_model(measurement);
            
            // Early termination if convergence reached
            if self.surface_error_estimate() < 0.05 {
                break;
            }
        }
        
        Ok(self.generate_compensation_mesh())
    }
}
```

**Safety Verification**:
We can prove this approach maintains print quality because:
1. Interpolation error â¤ 0.05mm with 95% confidence (proven via Gaussian process bounds)
2. Rust's ownership system prevents using invalidated probe data after thermal drift
3. Const generics ensure grid size matches allocated memory at compile time

**Edge Case Analysis**:
Consider thermal expansion during long prints:
- Mathematical bounds: |âz/âT| â¤ 0.003mm/Â°C over aluminum bed
- Rust safety: ProbePoint.timestamp prevents using measurements older than thermal time constant  
- Hardware reality: If temperature change > 5Â°C, trigger automatic recalibration

**Alternative Approaches & Trade-offs**:
We could use continuous mesh refinement instead of fixed grids, but this adds complexity without significant quality improvement for typical print geometries. The fixed-grid approach with adaptive early termination provides the best balance of simplicity, speed, and accuracy for our constraints.

Begin your analysis by identifying the most critical control systems in Klipper's codebase and extracting the fundamental reasoning patterns that make them effective.
